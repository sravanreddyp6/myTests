# Regression Tests

## Overview

Our regression test suite runs on top of NodeJS, Selenium and WebdriverIO to automate Google Chrome
and run our test cases. It uses GulpJS as the task runner and Mocha/Chai as the test runner.

## How to run

Please refer to [this documentation](https://wiki.thementornetwork.com/display/IEADD/Regression+Tests+Set+Up)
for details on how to set up and run the test suite in Windows.

## Documentation

We use [WebdriverIO](http://webdriver.io/) to communicate with Selenium; therefore you can use the
WebdriverIO [API](http://webdriver.io/api.html) as a great starting point to automate the browser.
I've also included many helper functions to help us interface with Visualforce a little bit easier,
a lot of them allow you to fill in/get value out of Visualforce using labels instead of the DOM IDs.
If possible, please use these functions because it matches better with our users' experience.

- `logInAs(user)`: Log in as a particular user, afterwards you can expect to end up at the
ESD Home Page. This method will take into account multiple scenarios, including initial password
change bypass and wrong passwords.
Please see [User Management](#markdown-header-user-management) for more information.
- `callHook(hookName)`: In a utility, this represents a hook point that a developer can use
to modify the utility behavior.
Please see [Hooks](#markdown-header-hooks) for more information.
- `execUtil(utilName, opts)`: Executing the utility function `utilName` with `opts` as
the options.
Please see [Utilities](#markdown-header-utilities) for more information.
- `fillInputText(label, value, fromNodeSelector)`: Fill a Visualforce `inputText` or `inputField`
that has label `label` with `value`. `fromNodeSelector` is optional, please look below
for documentation on this parameter.
- `fillInputsWithData(data)`: A special method that fills in the fields on a page with data
that follow certain schema.
- `getPageMessage(pageMessageId)`: Get the page messages generated by Visualforce. The result
is a list of all page messages visible on the page, unless `pageMessageId` is passed in, in
which case only the messages that are descendants of that particular pageMessage element will be
returned.
- `getOutputText(label, fromNodeSelector)`: Get the value from a Visualforce `outputText` or
`outputField` with label `label`. `fromNodeSelector` is optional, please look below
for documentation on this parameter.
- `getOutputTextFromInput(label, fromNodeSelector)` : Get the value from a Visualforce
`InputText` or `InputField` with label `label`. This will be useful in validating the field
values in edit mode. `fromNodeSelector` is optional, please look below for documentation on
this parameter.
- `getSelectOptions(label,resultInLabel, fromNodeSelector)`: Get all the options
from a `select` tag with label `label`. If `resultInLabel` is not specified, the values of
the options will be returned; otherwise if `resultInLabel` is `true`, the text strings will
be returned.  `fromNodeSelector` is optional, please look below for documentation on this parameter.
- `getSelectOptionsBySelector(selector, resultInLabel)`: Get all the options from a `select` tag with
selector `selector`. Use this only when `getSelectOptions` is not viable (e.g. when there
are multiple elements with the same label on the page). If `resultInLabel` is not specified,
the values of the options will be returned; otherwise if `resultInLabel` is `true`,
the text strings will be returned.
- `getMultiSelectOptions(label, resultInLabel, fromNodeSelector)`: similar to
`getSelectOptions`, however it used for multi select options instead of single select options.
`fromNodeSelector` is optional, please look below for documentation on this parameter.
- `getCheckboxOutput(label, fromNodeSelector)`: Get whether a checkbox output with
Visualforce `apex:outputField` with label `label` is checked or not. If it is, the function
returns true, otherwise it returns false. `fromNodeSelector` is optional, please look below
for documentation on this parameter.
- `getCheckboxOutputBySelector(selector)`: same as `getCheckboxOutput`, but with
a selector instead of a label.
- `getCheckboxOutputs(label1, label2, ...)`: A helper to get multiple checkbox output
values. It returns a list of Booleans, directly corresponding to the checkboxess labels passed in.
For example: if we have 2 checkboxes: Checkbox 1 (checked) and Checkbox 2 (unchecked), calling
`getCheckboxes("Checkbox 1", "Checkbox 2")` will return `[true, false]`.
- `getCheckboxInput(label, fromNodeSelector)`: Get whether a checkbox input with label
`label` is checked or not. If it is, the function returns true, otherwise it returns false.
`fromNodeSelector` is optional, please look below for documentation on this parameter.
- `getCheckboxInputs(label1, label2, ...)`: same as `getCheckboxOutputs`, but on
input fields instead of output fields.
- `chooseSelectOption(label, text, selectByLabel, fromNodeSelector)`: Choose an
option from a `select` with label `label`. By default, the framework will choose the option
with the value `text`; however, if `selectByLabel` is true, the option containing the text
string `text` will be chosen. `fromNodeSelector` is optional, please look below for
documentation on this parameter.
- `chooseMultiSelectOption(label, texts, selectByLabel, fromNodeSelector)`: the
same as `chooseSelectOption`, but with a Visualforce generated multi select option instead. `texts`
is an array of options to select (for example, `["Option 1", "Option 2"]`). Note that if
the `select` element already has some selected options before this function is called, those
*will* be cleared out first before `texts` are chosen. `fromNodeSelector` is optional,
please look below for documentation on this parameter.
- `selectCheckbox(label, fromNodeSelector)`: Select a checkbox with label `label`.
`fromNodeSelector` is optional, please look below for documentation on this parameter.
- `unselectCheckbox(label, fromNodeSelector)`: Unselect a checkbox with label `label`.
`fromNodeSelector` is optional, please look below for documentation on this parameter.
- `selectCheckboxBySelector(selector)`: Select a checkbox with selector `selector`.
- `unselectCheckboxBySelector(selector)`: Unselect a checkbox with selector `selector`.
- `selectCheckboxes(label1, label2, ...)`: A helper to select multiple checkboxes at the
same time. Example usage: `selectCheckboxes("Checkbox 1", "Checkbox 2")` will select
the checkboxes with labels Checkbox 1 and Checkbox 2.
- `unselectCheckboxes(label1, label2, ...)`: Same as `selectCheckboxes`, but it
unselects the checkboxes instead.
- `selectLookup(label, fromNodeSelector)`: Click on a lookup icon that Visualforce
generated for certain elements (e.g. when we need to look up a user). `fromNodeSelector` is
optional, please look below for documentation on this parameter.
- `switchToNextWindow()`: Sometimes VF will create a new window (e.g. when we look up a
user). You can use this function to switch between windows in that case.
- `tableToJSON(selector)`: Turns a table with selector `selector` to a JSON object. Please
read more about [handing table](#markdown-header-handling-table).
- `waitForActionStatusDisappearance(actionStatusId, timeout)`: Wait for an
`apex:actionStatus` to disappear.
- `unstickPbsCard()`: sometimes we'll run into issues where the PBS card floating on top of
the page would block Chrome from clicking an element. Instead of scrolling past it, another option
would be to unstick it. Call this method in order to do that.

A lot of these custom commands accept the parameter `fromNodeSelector`. This is an optional
parameter that, when specified, only look for an element that is a child of the DOM node with that
selector. For example, if you use `client.fillInputtext("First Name", "div[id$=admission]")`
and there are two First Name fields on the page, only the one that is a children of
`div[id$=admission]` will be filled.

A note of caution: NodeJS (and Javascript in general) is inherently a single thread, asynchronous
language. This means that a lot of the time, code are run on a callback basis - and after awhile,
we can run into [Callback Hell](http://callbackhell.com/). Modern Javascript libraries (WebdriverIO
in this case) use a technique called Promises to get rid of this problem. Basically, Promises will
reduce the following code:

```
step1(function (value1) {
    step2(value1, function(value2) {
        step3(value2, function(value3) {
            step4(value3, function(value4) {
                // Do something with value4
            });
        });
    });
});
```

into:

```
step1()
.then(promisedStep2)
.then(promisedStep3)
.then(promisedStep4)
.then(function (value4) {
    // Do something with value4
})
.catch(function (error) {
    // Handle any error from all above steps
})
.done();
```

If you're interested in Promises in general, [this article](http://www.html5rocks.com/en/tutorials/es6/promises/)
is a good starting point. However, for our purposes of writing regression tests, most of the time
we won't have delve too deep into the Promise specification. What you do need to know is Promise
Chaining. Basically, instead of assigning the value returned from a function to a variable, you
have to pass that value into a `then` function. In other words, *don't* do this:

```
var firstName = client.getOutputText("First Name");
assert.equals("Susan", firstName);
```

This will *not* work, because `getOutputText` returns a Promise, not the actual value. Instead,
do this:

```
client
  .getOutputText("First Name")
  .then(function (firstName) {
    assert.equals("Susan", firstName);
  });
```

As a side effect of this, most of the time your code in a test case should just be a long chain
of method calls starting from `client` like this:

```
return client
  .url()
  .then(...)
  .click(...)
  .click(...)
  .getSelectOptions(...)
  .then(...);
```

If instead, you find your code looks like this:

```
client
  .url()
  .then(...);
var a = "";
a += "Hello World";
client.getSelectOptions(...);
```

In other words, your chain is broken up in the middle, there's a very high likelihood that the code
will not work the way you think it does! Javascript is an async language, it's almost a certainty
that the code in the middle will run _before_ anything else. If you need to pass results between
functions, you can do the following instead:

```
client.
  .then(function () {
    var a = "";
    a += "Hello World";
    return a;
  })
  .then(function (resultFromLastFunction) {
    console.log(resultFromLastFunction);  // it will print out Hello World here
  });
```

Whatever you `return` from your last function will be passed in as a parameter in your next
function in the Promise chain!

What if you want a result to be reused multiple times throughout the chain? One way to handle this
is to declare a variable before the chain and refer to it throughout:

```
var a;

client.
  .then(function () {
    a = "Hello World";
  })
  .then(function () {
    console.log(a);  # print out Hello World
  })
  .then(function () {
    console.log(a + ";");  # print out Hello World;
  });
```

### User Management

When we're running regression tests, we want to be able to test using users with the same role,
profile, permission set and public group as real users in production. Because of this,
the framework has a built in user management module that (most of the time) will just work out of
the box. The only thing you need to do is to add a user to the `configs/users.json`
(following the existing examples there) and the script will make sure that user is created with the
correct permissions/groups/roles before running your test. Please note existing users will not
be modified, therefore you should never modified the users specified in the
`configs/users.json` manually, as it will lead to inconsistent results down the road.
In order to get access to these user accounts in your test suites, it is as simple as doing:

```
var users = require("../users.js").accounts;
```

From there you can refer to the user account by their name,
e.g. `users['CM_Referral_Intaker']`. You can also get all the properties defined in the
`users.json` file like so:

```
users['CM_Referral_Intaker'].password
```

This will come in handy when you need to e-sign a document, for example.

There is also a custom command called `logInAs(user)` that lets you log in as a user defined
in the `users.json` file. In order to user this, simple pass in a user object like so:

```
client.logInAs(users['CM_Referral_Intaker']).then(...);
```

### Utilities

There are certain things that need to be run over and over in our test suites (e.g. creating/
converting referral), so I've created some utility functions that can make this process easier.
These functions can be found in the `utils` directory, and calling them is as easy as doing
`client.execUtil("util_name", options)`, in which `util_name` is the file name of
the util you want to run. `options` is a Javascript object containing the options that will
change the behavior of the utility; for example, the `create_referral` utility accepts
`operatingGroup` and `flavor` as options - it then creates referrals with different fields
based on the operating group and flavor that are passed in. In order to find which options a util
function takes, please look at the source code - they should be listed on top of the file.

#### Hooks

A lot of the times, executing a utility is not enough. For example, if we use the `create_referral`
util but also want to add a Related Party during the referral creation, we need to somehow hook
into the referral creation process. This is achieved by (you guess it) a hook system built into
the framework. When `execUtil` is called, it accepts a `hooks` object inside the `opts`
parameter that allow you to do different things at different times during the util execution. For
example, the following code:

```
return client
  .execUtil("create_referral", {
    operatingGroup: "Redwood",
    flavor: "AZ",
    hooks: {
      "create_referral_before_pbr_submit": function (client) {
        return client.chooseSelectOption("Ethnicity", "African");
      }
    }
  })
```

will choose the African option in the Ethnicity select right before the Create PBR button on the
referral page is clicked. This is very powerful, since you can hook onto many different points
during the util execution to fill inputs/do assertions that are necessary. To find the hooks
available in each util, please refer to the source code.


### Handling Table

Table handling is tricky in Visualforce pages, since the rows and columns are given unique (but not
easily predictable across sandboxes) Ids - making it harder to write correct selectors for them.
Because of this issue, I've written the `tableToJSON` custom command to handle simple tables.
Call this method with a selector to the `table` element, and it will return a JSON string
representation of that table, with the keys being the column names and the values being the content
of the cells in the table. For example, this table (with id `sample-table`):

Name       | Value
---------- | -------
Record 1   | Value 1
Record 2   | Value 2

will be transformed into the JSON object
`[{"Name": "Record 1", "Value": "Value 1"}, {"Name": "Record 2", "Value": "Value 2"}]`.

Of course, this method only returns the content of the table. In case you want to interact with a
certain cell in the table, please use the `nth-child` selector in the CSS specification. For
example, to click on a link in the table at row 5 (excluding the header row) and column 3, you can
do:

`return client.click("table#id tbody tr:nth-child(5) td:nth-child(3) a");`

Please note that the `nth-child` selector uses a 1-based indexing system - so the first row has
index 1, second row has index 2, and so on.

## FAQ

- My suite exits way too fast and doesn't seem to do anything!

Make sure that you're returning a Promise in your test case, a.k.a:

```
testSuite("Sample Suite", suiteTimeout, {
  "should do the right thing": function(client, done) {
    return client
      .logInAs(users["CM_Tier_I"])
      .url()
      .then(function (url) {
        assert.include(url.value, 'Home');
      });
  }
});

```

If you don't have that `return` statement, the script will exit almost immediately and will do
nothing, so make sure it's there.

- How to refer to elements by their IDs?

First off, I'd recommend to always use the custom commands in the [Documentation](#documentation)
as much as you can. However, there will be situations where that is impossible and we have to refer
to some elements by their IDs directly. The issue arises where Visualforce generated IDs are not
guaranteed to be the same across multiple sandboxes, and so we cannot pass in the full IDs into
Webdriver's methods. For example, let's take a look at `click`:

```
# Do NOT do this!
client.click("j_id0:referralForm:referralDetailBlock:ReferralDetailHeader:referrerPhone").then(...);

# Instead you can use a partial selector in this situation:
client.click("[id$=referrerPhone]").then(...);
```

This is fairly similar to how we use JQuery selectors on the client side, so hopefully it won't be
too hard. WebdriverIO also supported multiple ways of specifying selectors (not just CSS selector),
and you can find them all [here](http://webdriver.io/guide/usage/selectors.html).